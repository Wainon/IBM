# Модуль авторизации, написан на Go?/или что-то 

## Рабтал на ним:
Рузанов Олег

# Сценарй 
Пользователь может находится в одном из состояний:

Неизвестный --(обращение к сервису)--> Анонимный --(вход)--> Авторизованный --(выход)--> Не известный.

<br/>

#### Модулю Авторизации приходит запрос авторизации пользователя (через GitHub или Яндекс)

Сценарий один и тот же могут быть мелкие отличия в названии параметров (смотрите описание API: [yandex](https://yandex.ru/dev/id/doc/ru/codes/code-url), [github](https://docs.github.com/ru/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps)).

1. Модулю Авторизации приходит запрос авторизации пользователя с типом *github* или *yandex* и токеном входа (формирует и присылает модуль Telegram клиент или Web клиент);
2. *Authorization Server* берёт ссылку на *github* или *yandex* соответственно, добавляет параметр *client_id* (должен быть получен у *github* и *yandex* во время регистрации приложения) и параметр *state* (равен токену входа);
3. *Authorization Server* формирует структуру из 2 полей: Устареет через: текущее время + 5 минут и Статус ответа от пользователя: не получен. Структура сохраняется в словарь, где в качестве ключа используется токен входа; 
4. *Authorization Server* отправляет в качестве ответе ссылку полученную на шаге 2.

Эта ссылка будет показан пользователю модулем Telegram клиент или Web клиент. Перейдя по ссылке пользователь может подтвердить вход, отказаться от входа или закрыть страницу. Первые два случая приведут к тому, что *github* или *yandex* обратятся к модулю Авторизации и пришлют ошибку (если пользователь отказался) и код (если пользователь согласился). Дополнительно присылается параметр *state* тот, что мы сами указали без изменения.

5. *Authorization Server* получил обращение от *github* или *yandex*:
6. Если пришла ошибка:

   - Берём параметр *state* и используем его в качестве ключа для словаря созданного ранее (если такого ключа нет в словаре, просто игнорируем его) и устанавливаем Статус ответа от пользователя: в доступе отказано;
   - Отвечаем *github* или *yandex* web-страницей сообщающей об неудачной авторизации (страница будет показана пользователю).
7. Если пришёл код:

   - Делаем свой запрос к *github* или *yandex* соответственно и обмениваем код + свои параметры (смотрите API) на токен доступа (этот токен доступа к данным);
   - Делаем второй запрос к *github* или *yandex* соответственно (добавляя токен доступа) и просим прислать данные о пользователе;
   - Если данные пришли достаём почту;
   - Делаем запрос в *mongoDB* и ищем пользователя с соответствующей почтой.
   - Если пользователь есть, то:
     - Достаём данные о его ролях;
   - Если пользователя нет, то:
     - Формируем учётную запись с именем Аноним+номер, ролью "Студент" и пустым список токенов доступа и добавляем её в базу данных;
   
    - Формируем список разрешений на основе ролей пользователя;
   
   
   - Формируем *JWT* токен доступа на основе: списка разрешений, текущего времени + 1 минута (время устаревания токена доступа);
      - Формируем *JWT* токен обновления на основе: почты пользователя, текущего времени + 7*24 часа (время устаревания токена обновления);
   
   - Токен обновления записываем в базу данных в список токенов пользователя;
   - Берём параметр *state* и используем его в качестве ключа для словаря созданного ранее (если такого ключа нет в словаре, просто игнорируем его) и устанавливаем Статус ответа от пользователя: доступ предоставлен и добавляем токен доступа и токен обновления;
   - Отвечаем *github* или *yandex* web-страницей сообщающей об успешной авторизации и предложением перейти обратно в приложение (страница будет показана пользователю).
   

#### Модулю Авторизации приходит запрос авторизации пользователя (через Код)

1. Модулю Авторизации приходит запрос авторизации пользователя с типом *code* и токеном входа (формирует и присылает модуль Telegram клиент или Web клиент);
2. *Authorization Server* делает запрос компоненту *Code Authentication*:
   - *Code Authentication* генерирует случайный код (5-6 цифр) и формирует структуру состоящую из токена входа и текущего времени + 1 минута (время устаревания кода);
   - *Code Authentication* добавляет в словарь новую запись с ключом равным сгенерированному коду и структурой в качестве значения;
   - *Code Authentication* отвечает на запрос от *Authorization Server* сгенерированным кодом.
3. *Authorization Server* формирует структуру из 2 полей: Устареет через: текущее время + 5 минут и Статус ответа от пользователя: не получен. Структура сохраняется в словарь, где в качестве ключа используется токен входа; 
4. *Authorization Server* отправляет в качестве ответа код полученный на шаге 2.

Этот  код должен быть показан Telegram клиентом или Web клиентом (в зависимости от того, кто был инициатором запроса). Пользователь должен взять устройство на котором он авторизован и ввести код или может ничего не делать.

5. Пользователь берёт устройство на котором он авторизован и вводит код;
6. Соответствующий клиент делает запрос компоненту *Code Authentication* (в нашем случае не напрямую а через *Authorization Server*, который просто пересылает запрос) и добавляет туда код и токен обновления;
7. *Code Authentication* достает из запроса код и ищет его в словаре.
8. Если кода нет или он устарел:

   - *Code Authentication* делает запрос компоненту *Authorization Server* и присылает ему ошибку.
9. Если код есть:
   - *Code Authentication* достаёт из запроса токен обновления и проверяет подпись.
   - Если токен отсутствует или токен неправильно подписан *Code Authentication* делает запрос  компоненту *Authorization Server* и присылает ему ошибку.
10. Если всё ок:
    - *Code Authentication* делает запрос  компоненту *Authorization Server* и присылает ему код и *state* равной токену входа.

Далее выполняется всё тоже самое, что и для GitHub и Яндекс начиная с пункта 5. *Code Authentication* на запрос от *Authorization Server* с кодом отправляет почту пользователя которую он достаёт из токена обновления;

11. Ответ от *Authorization Server* пересылается обратно пользователю.

<br/>
