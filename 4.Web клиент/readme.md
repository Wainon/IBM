# Web клиент, написан на JS/HTML/css

## Рабтал на ним:
Сафонов Андрей

# Сценарий 
Пользователь может находится в одном из состояний:

Неизвестный --(обращение к сервису)--> Анонимный --(вход)--> Авторизованный --(выход)--> Не известный.

<br/>

#### Пользователь обращается к системе через новый браузер или после выхода (неизвестный пользователь)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);
2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;
4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. Если нужную куку не прислали, то запрос не делаем, а сразу считаем, что ответ от *Redis* отрицательный;
5. *Redis* сообщает, что такого ключа нет;
6. Если *URL* `/`:
   - Показываем пользователю страницу на которой пользователю предлагается авторизоваться через: GitHub, Яндекс ID или через код;
7. Если *URL* `/login` без параметров или любой другой:
   - *Web Client* отвечает браузеру редирект на главную;
8. Если *URL* `/login` с параметром `type`:
   - Генерируем новый токен сессии и новый токен входа;
   - Делаем запрос *Redis* чтобы он запомнил токен сессии как ключ, а в качестве значения: статус пользователя: Анонимный и токен входа;
   - *Web Client* делает запрос к модулю Авторизации (указывая токен входа);
   - Ждём ответа от модуль Авторизации и перенаправляем его браузеру. К ответу также добавляется просьба браузеру запомнить новый токен сессии в куки.

#### Пользователь обращается к системе через браузер (имея статус Анонимный)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);

2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;

3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;

4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя.

5. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;

6. *Web Client* достаёт из ответа статус пользователя. Он равен: Анонимный;

7. Если *URL* `/login` с параметром `type`:

   - Генерируем новый токен входа. Токен сессии остаётся прежний;

   - Делаем запрос *Redis* чтобы он обновил токен входа. В качестве ключа используется текущий токен сессии;

   - *Web Client* делает запрос к модулю Авторизации (указывая токен входа);

   - Ждём ответа от модуль Авторизации и перенаправляем его браузеру.

8. Если *URL* `/login` без параметров или любой другой:

9. *Web Client* достаёт из ответа от *Redis* токен входа и делает запрос модулю Авторизации отправляя токен входа для проверки;

10. Модуль Авторизации проверяет есть ли у него запись для указанного токена входа и отвечает.

11. Если ответ от модуля Авторизации: не опознанный токен или время действия токена закончилось:

    - *Web Client* делает запрос *Redis*, чтобы он удалил текущий ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
    - *Web Client* отвечает браузеру редирект на главную;

12. Если ответ от модуля Авторизации: в доступе отказано (пользователь нажал Нет во время входа):

    - *Web Client* делает запрос *Redis*, чтобы он удалил текущий ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
    - *Web Client* отвечает браузеру редирект на главную;

13. Если ответ от модуля Авторизации: доступ предоставлен (пользователь нажал Да во время входа), то:

    - *Web Client* проверяет, что в ответе от модуля авторизации присутствуют 2 *JWT* токена: токен доступа (*Access Token*) и токен обновления (*Refresh Token*);
    - Они присутствуют. *Web Client* меняет статус пользователя на Авторизованный и делает запрос *Redis* сохранить новый статус пользователя и оба *JWT* токена (токен входа больше не нужен). В качестве ключа используется токен сессии;
    - *Web Client* продолжает обрабатывать текущий запрос пользователя так, как будто бы пользователь сразу был в статусе Авторизованный.

#### Пользователь обращается к системе через браузер (имея статус Авторизованный)

1. Пользователь открывает браузер и указывает адрес модуля *Web клиент* (любой *url*);
2. Браузер отправляет запрос на компонент *Nginx*. При этом браузер автоматически оправляет куки;
3. *Nginx* перенаправляет запрос одной из рабочих копий компонента *Web Client*;
4. *Web Client* делает запрос к компоненту *Redis* используя токен сессии из кук в качестве ключа. На этот раз он 100% есть, иначе продолжение по сценарию Неизвестного пользователя.
5. *Redis* сообщает, что такой ключ есть и присылает данные соответствующие ключу;
6. *Web Client* достаёт из ответа статус пользователя. Он равен: Авторизованный;
7. Если *URL* `/`:
   - *Web Client* отвечает браузеру страницей личного кабинета пользователя (информация о пользователе, список его дисциплин, и т.д.);
8. Если *URL* `/login` не важно с параметром или без:
   - *Web Client* отвечает браузеру редирект на главную `/`;
9. Если *URL* `/logout` без параметров (выйти из системы на этом устройстве):
   - *Web Client* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
   - *Web Client* отвечает браузеру редирект на главную `/`;
10. Если *URL* `/logout` с параметром `all=true` (выйти из системы на всех устройствах):

       - *Web Client* делает запрос к компоненту *Redis* и просит удалить ключ. В качестве ключа используется токен сессии. Пользователь переходит в статус Неизвестный.
       - *Web Client* делает запрос к модулю Авторизации на `/logout` и отправляет ему токен обновления;
       - *Web Client* отвечает браузеру редирект на главную `/`;
11. Если *URL* другой (самостоятельно назначить для каждого действия которое можно выполнить в системе):
    - *Web Client* делает соответствующий запрос к Главному модулю передавая токен доступа в заголовках запроса;
    - Если токен доступа не устарел и у пользователя есть право на выполнение действия:
      - Главный модуль обрабатывает запрос и отвечает данными;
      - *Web Client* формирует страницу ответа на основе данных и отправляет её браузеру;
    - Если токен доступа не устарел, но у пользователя нет права на выполнение действия:
      - Главный модуль отвечает 403 кодом;
      - *Web Client* формирует страницу с сообщением об отсутствии доступа и отвечает браузеру;
    - Если токен доступа устарел:
      - Главный модуль отвечает 401 кодом;
      - *Web Client* формирует запрос к модулю Авторизации и отправляет токен обновления.
        - Если токен обновления устарел или не существует:
          - Модуль Авторизации отвечает 401 кодом и удаляет у себя устаревший токен;
          - Web Client отправляет запрос *Redis* и просит удалить указанный ключ. Ключ - это токен сесии. Пользователь переходит в статус Неизвестный;
          - *Web Client* отвечает браузеру редирект на главную `/`;
        - Если токен обновления валидный:
          - Модуль Авторизации создаёт новую пару токен доступа + токен обновления и заменяет у себя старый токен обновления новым. Новую пару отправляет в качестве ответа;
          - Web Client отправляет запрос *Redis* и просит заменить токены на новые для указанного ключа. Ключ - это токен сессии;
          - Повторно пытаемся выполнить запрос пользователя (переходим в начало этого пункта);

<br/>
